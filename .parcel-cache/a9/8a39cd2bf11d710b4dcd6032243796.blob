var { useMemo , useState , useEffect , useReducer  } = require("react");
var _babelRuntimeHelpersExtends = $parcel$interopDefault(require("@babel/runtime/helpers/extends"));
function $parcel$interopDefault(a) {
    return a && a.__esModule ? a.default : a;
}
/**
 * Manages state for an immutable list data structure, and provides convenience methods to
 * update the data over time.
 */ function useListData(options) {
    let { initialItems =[] , initialSelectedKeys , getKey =(item)=>item.id || item.key
     , filter , initialFilterText =''  } = options; // Store both items and filteredItems in state so we can go back to the unfiltered list
    let [state, setState] = useState({
        items: initialItems,
        selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys || []),
        filterText: initialFilterText
    });
    let filteredItems = useMemo(()=>filter ? state.items.filter((item)=>filter(item, state.filterText)
        ) : state.items
    , [
        state.items,
        state.filterText,
        filter
    ]);
    return _babelRuntimeHelpersExtends({
    }, state, {
        items: filteredItems
    }, $f237d9b45bc5fe911ce76292c069bdd7$export$createListActions({
        getKey
    }, setState), {
        getItem (key) {
            return state.items.find((item)=>getKey(item) === key
            );
        }
    });
}
exports.useListData = useListData;
function $f237d9b45bc5fe911ce76292c069bdd7$export$createListActions(opts, dispatch) {
    let { getKey  } = opts;
    return {
        setSelectedKeys (selectedKeys) {
            dispatch((state)=>_babelRuntimeHelpersExtends({
                }, state, {
                    selectedKeys
                })
            );
        },
        setFilterText (filterText) {
            dispatch((state)=>_babelRuntimeHelpersExtends({
                }, state, {
                    filterText
                })
            );
        },
        insert (index) {
            for(var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)values[_key - 1] = arguments[_key];
            dispatch((state)=>$f237d9b45bc5fe911ce76292c069bdd7$var$insert(state, index, ...values)
            );
        },
        insertBefore (key) {
            for(var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)values[_key2 - 1] = arguments[_key2];
            dispatch((state)=>{
                let index = state.items.findIndex((item)=>getKey(item) === key
                );
                if (index === -1) return;
                return $f237d9b45bc5fe911ce76292c069bdd7$var$insert(state, index, ...values);
            });
        },
        insertAfter (key) {
            for(var _len3 = arguments.length, values = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++)values[_key3 - 1] = arguments[_key3];
            dispatch((state)=>{
                let index = state.items.findIndex((item)=>getKey(item) === key
                );
                if (index === -1) return;
                return $f237d9b45bc5fe911ce76292c069bdd7$var$insert(state, index + 1, ...values);
            });
        },
        prepend () {
            for(var _len4 = arguments.length, values = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++)values[_key4] = arguments[_key4];
            dispatch((state)=>$f237d9b45bc5fe911ce76292c069bdd7$var$insert(state, 0, ...values)
            );
        },
        append () {
            for(var _len5 = arguments.length, values = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++)values[_key5] = arguments[_key5];
            dispatch((state)=>$f237d9b45bc5fe911ce76292c069bdd7$var$insert(state, state.items.length, ...values)
            );
        },
        remove () {
            for(var _len6 = arguments.length, keys = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++)keys[_key6] = arguments[_key6];
            dispatch((state)=>{
                let keySet = new Set(keys);
                let items = state.items.filter((item)=>!keySet.has(getKey(item))
                );
                let selection = new Set(state.selectedKeys);
                for (let key of keys)selection.delete(key);
                return _babelRuntimeHelpersExtends({
                }, state, {
                    items,
                    selectedKeys: selection
                });
            });
        },
        removeSelectedItems () {
            dispatch((state)=>{
                if (state.selectedKeys === 'all') return _babelRuntimeHelpersExtends({
                }, state, {
                    items: [],
                    selectedKeys: new Set()
                });
                let selectedKeys = state.selectedKeys;
                let items = state.items.filter((item)=>!selectedKeys.has(getKey(item))
                );
                return _babelRuntimeHelpersExtends({
                }, state, {
                    items,
                    selectedKeys: new Set()
                });
            });
        },
        move (key, toIndex) {
            dispatch((state)=>{
                let index = state.items.findIndex((item)=>getKey(item) === key
                );
                if (index === -1) return state;
                let copy = state.items.slice();
                let [item] = copy.splice(index, 1);
                copy.splice(toIndex, 0, item);
                return _babelRuntimeHelpersExtends({
                }, state, {
                    items: copy
                });
            });
        },
        moveBefore (key, keys) {
            dispatch((state)=>{
                let toIndex = state.items.findIndex((item)=>getKey(item) === key
                );
                if (toIndex === -1) return state;
                 // Find indices of keys to move. Sort them so that the order in the list is retained.
                let indices = keys.map((key)=>state.items.findIndex((item)=>getKey(item) === key
                    )
                ).sort();
                return $f237d9b45bc5fe911ce76292c069bdd7$var$move(state, indices, toIndex);
            });
        },
        moveAfter (key, keys) {
            dispatch((state)=>{
                let toIndex = state.items.findIndex((item)=>getKey(item) === key
                );
                if (toIndex === -1) return state;
                let indices = keys.map((key)=>state.items.findIndex((item)=>getKey(item) === key
                    )
                ).sort();
                return $f237d9b45bc5fe911ce76292c069bdd7$var$move(state, indices, toIndex + 1);
            });
        },
        update (key, newValue) {
            dispatch((state)=>{
                let index = state.items.findIndex((item)=>getKey(item) === key
                );
                if (index === -1) return state;
                return _babelRuntimeHelpersExtends({
                }, state, {
                    items: [
                        ...state.items.slice(0, index),
                        newValue,
                        ...state.items.slice(index + 1)
                    ]
                });
            });
        }
    };
}
function $f237d9b45bc5fe911ce76292c069bdd7$var$insert(state, index) {
    for(var _len7 = arguments.length, values = new Array(_len7 > 2 ? _len7 - 2 : 0), _key7 = 2; _key7 < _len7; _key7++)values[_key7 - 2] = arguments[_key7];
    return _babelRuntimeHelpersExtends({
    }, state, {
        items: [
            ...state.items.slice(0, index),
            ...values,
            ...state.items.slice(index)
        ]
    });
}
function $f237d9b45bc5fe911ce76292c069bdd7$var$move(state, indices, toIndex) {
    // Shift the target down by the number of items being moved from before the target
    for (let index of indices)if (index < toIndex) toIndex--;
    let moves = indices.map((from)=>({
            from,
            to: toIndex++
        })
    ); // Shift later from indices down if they have a larger index
    for(let i = 0; i < moves.length; i++){
        let a = moves[i].from;
        for(let j = i; j < moves.length; j++){
            let b = moves[j].from;
            if (b > a) moves[j].from--;
        }
    } // Interleave the moves so they can be applied one by one rather than all at once
    for(let i1 = 0; i1 < moves.length; i1++){
        let a = moves[i1];
        for(let j = moves.length - 1; j > i1; j--){
            let b = moves[j];
            if (b.from < a.to) a.to++;
            else b.from++;
        }
    }
    let copy = state.items.slice();
    for (let move of moves){
        let [item] = copy.splice(move.from, 1);
        copy.splice(move.to, 0, item);
    }
    return _babelRuntimeHelpersExtends({
    }, state, {
        items: copy
    });
}
function $fbe26d4ebdaa302e354dcbb53fc6447$var$reducer(data, action) {
    var _action$filterText, _action$sortDescripto, _action$filterText2, _action$selectedKeys, _action$sortDescripto2, _action$filterText3, _action$selectedKeys2, _action$sortDescripto3, _action$filterText4;
    switch(data.state){
        case 'idle':
        case 'error':
            switch(action.type){
                case 'loading':
                case 'loadingMore':
                case 'sorting':
                case 'filtering':
                    return _babelRuntimeHelpersExtends({
                    }, data, {
                        filterText: (_action$filterText = action.filterText) != null ? _action$filterText : data.filterText,
                        state: action.type,
                        // Reset items to an empty list if loading, but not when sorting.
                        items: action.type === 'loading' ? [] : data.items,
                        sortDescriptor: (_action$sortDescripto = action.sortDescriptor) != null ? _action$sortDescripto : data.sortDescriptor,
                        abortController: action.abortController
                    });
                case 'update':
                    return _babelRuntimeHelpersExtends({
                    }, data, action.updater(data));
                case 'success':
                case 'error':
                    return data;
                default:
                    throw new Error("Invalid action \"" + action.type + "\" in state \"" + data.state + "\"");
            }
        case 'loading':
        case 'sorting':
        case 'filtering':
            switch(action.type){
                case 'success':
                    // Ignore if there is a newer abortcontroller in state.
                    // This means that multiple requests were going at once.
                    // We want to take only the latest result.
                    if (action.abortController !== data.abortController) return data;
                    return _babelRuntimeHelpersExtends({
                    }, data, {
                        filterText: (_action$filterText2 = action.filterText) != null ? _action$filterText2 : data.filterText,
                        state: 'idle',
                        items: [
                            ...action.items
                        ],
                        selectedKeys: new Set((_action$selectedKeys = action.selectedKeys) != null ? _action$selectedKeys : data.selectedKeys),
                        sortDescriptor: (_action$sortDescripto2 = action.sortDescriptor) != null ? _action$sortDescripto2 : data.sortDescriptor,
                        abortController: null,
                        cursor: action.cursor
                    });
                case 'error':
                    if (action.abortController !== data.abortController) return data;
                    return _babelRuntimeHelpersExtends({
                    }, data, {
                        state: 'error',
                        error: action.error,
                        abortController: null
                    });
                case 'loading':
                case 'loadingMore':
                case 'sorting':
                case 'filtering':
                    // We're already loading, and another load was triggered at the same time.
                    // We need to abort the previous load and start a new one.
                    data.abortController.abort();
                    return _babelRuntimeHelpersExtends({
                    }, data, {
                        filterText: (_action$filterText3 = action.filterText) != null ? _action$filterText3 : data.filterText,
                        state: action.type,
                        // Reset items to an empty list if loading, but not when sorting.
                        items: action.type === 'loading' ? [] : data.items,
                        abortController: action.abortController
                    });
                case 'update':
                    // We're already loading, and an update happened at the same time (e.g. selectedKey changed).
                    // Update data but don't abort previous load.
                    return _babelRuntimeHelpersExtends({
                    }, data, action.updater(data));
                default:
                    throw new Error("Invalid action \"" + action.type + "\" in state \"" + data.state + "\"");
            }
        case 'loadingMore':
            switch(action.type){
                case 'success':
                    // Append the new items
                    return _babelRuntimeHelpersExtends({
                    }, data, {
                        state: 'idle',
                        items: [
                            ...data.items,
                            ...action.items
                        ],
                        selectedKeys: new Set([
                            ...data.selectedKeys,
                            ...(_action$selectedKeys2 = action.selectedKeys) != null ? _action$selectedKeys2 : []
                        ]),
                        sortDescriptor: (_action$sortDescripto3 = action.sortDescriptor) != null ? _action$sortDescripto3 : data.sortDescriptor,
                        abortController: null,
                        cursor: action.cursor
                    });
                case 'error':
                    if (action.abortController !== data.abortController) return data;
                    return _babelRuntimeHelpersExtends({
                    }, data, {
                        state: 'error',
                        error: action.error
                    });
                case 'loading':
                case 'sorting':
                case 'filtering':
                    // We're already loading more, and another load was triggered at the same time.
                    // We need to abort the previous load more and start a new one.
                    data.abortController.abort();
                    return _babelRuntimeHelpersExtends({
                    }, data, {
                        filterText: (_action$filterText4 = action.filterText) != null ? _action$filterText4 : data.filterText,
                        state: action.type,
                        // Reset items to an empty list if loading, but not when sorting.
                        items: action.type === 'loading' ? [] : data.items,
                        abortController: action.abortController
                    });
                case 'loadingMore':
                    // If already loading more and another loading more is triggered, abort the new load more since
                    // it is a duplicate request since the cursor hasn't been updated.
                    // Do not overwrite the data.abortController
                    action.abortController.abort();
                    return data;
                case 'update':
                    // We're already loading, and an update happened at the same time (e.g. selectedKey changed).
                    // Update data but don't abort previous load.
                    return _babelRuntimeHelpersExtends({
                    }, data, action.updater(data));
                default:
                    throw new Error("Invalid action \"" + action.type + "\" in state \"" + data.state + "\"");
            }
        default:
            throw new Error("Invalid state \"" + data.state + "\"");
    }
}
/**
 * Manages state for an immutable async loaded list data structure, and provides convenience methods to
 * update the data over time. Manages loading and error states, pagination, and sorting.
 */ function useAsyncList(options) {
    const { load , sort , initialSelectedKeys , initialSortDescriptor , getKey =(item)=>item.id || item.key
     , initialFilterText =''  } = options;
    let [data, dispatch] = useReducer($fbe26d4ebdaa302e354dcbb53fc6447$var$reducer, {
        state: 'idle',
        error: null,
        items: [],
        selectedKeys: new Set(initialSelectedKeys),
        sortDescriptor: initialSortDescriptor,
        filterText: initialFilterText
    });
    const dispatchFetch = async (action, fn)=>{
        let abortController = new AbortController();
        try {
            var _action$filterText5, _action$sortDescripto4, _response$filterText;
            dispatch(_babelRuntimeHelpersExtends({
            }, action, {
                abortController
            }));
            let previousFilterText = (_action$filterText5 = action.filterText) != null ? _action$filterText5 : data.filterText;
            let response = await fn({
                items: data.items.slice(),
                selectedKeys: data.selectedKeys,
                sortDescriptor: (_action$sortDescripto4 = action.sortDescriptor) != null ? _action$sortDescripto4 : data.sortDescriptor,
                signal: abortController.signal,
                cursor: action.type === 'loadingMore' ? data.cursor : null,
                filterText: previousFilterText
            });
            let filterText = (_response$filterText = response.filterText) != null ? _response$filterText : previousFilterText;
            dispatch(_babelRuntimeHelpersExtends({
                type: 'success'
            }, response, {
                abortController
            })); // Fetch a new filtered list if filterText is updated via `load` response func rather than list.setFilterText
            // Only do this if not aborted (e.g. user triggers another filter action before load completes)
            if (filterText && filterText !== previousFilterText && !abortController.signal.aborted) dispatchFetch({
                type: 'filtering',
                filterText
            }, load);
        } catch (e) {
            dispatch({
                type: 'error',
                error: e,
                abortController
            });
        }
    };
    useEffect(()=>{
        dispatchFetch({
            type: 'loading'
        }, load); // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    return _babelRuntimeHelpersExtends({
        items: data.items,
        selectedKeys: data.selectedKeys,
        sortDescriptor: data.sortDescriptor,
        isLoading: data.state === 'loading' || data.state === 'loadingMore' || data.state === 'sorting' || data.state === 'filtering',
        loadingState: data.state,
        error: data.error,
        filterText: data.filterText,
        getItem (key) {
            return data.items.find((item)=>getKey(item) === key
            );
        },
        reload () {
            dispatchFetch({
                type: 'loading'
            }, load);
        },
        loadMore () {
            // Ignore if already loading more or if performing server side filtering.
            if (data.state === 'loadingMore' || data.state === 'filtering' || data.cursor == null) return;
            dispatchFetch({
                type: 'loadingMore'
            }, load);
        },
        sort (sortDescriptor) {
            dispatchFetch({
                type: 'sorting',
                sortDescriptor
            }, sort || load);
        }
    }, $f237d9b45bc5fe911ce76292c069bdd7$export$createListActions(_babelRuntimeHelpersExtends({
    }, options, {
        getKey
    }), (fn)=>{
        dispatch({
            type: 'update',
            updater: fn
        });
    }), {
        setFilterText (filterText) {
            dispatchFetch({
                type: 'filtering',
                filterText
            }, load);
        }
    });
}
exports.useAsyncList = useAsyncList;
/**
 * Manages state for an immutable tree data structure, and provides convenience methods to
 * update the data over time.
 */ function useTreeData(options) {
    let { initialItems =[] , initialSelectedKeys , getKey =(item)=>item.id || item.key
     , getChildren =(item)=>item.children || []
      } = options;
    let map = useMemo(()=>new Map()
    , []); // We only want to compute this on initial render.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    let initialNodes = useMemo(()=>buildTree(initialItems)
    , []);
    let [items, setItems] = useState(initialNodes);
    let [selectedKeys, setSelectedKeys] = useState(new Set(initialSelectedKeys || []));
    function buildTree(initialItems1, parentKey) {
        return initialItems1.map((item)=>{
            let node = {
                key: getKey(item),
                parentKey: parentKey,
                value: item,
                children: null
            };
            node.children = buildTree(getChildren(item), node.key);
            map.set(node.key, node);
            return node;
        });
    }
    function updateTree(items1, key, update) {
        let node = map.get(key);
        if (!node) return items1;
         // Create a new node. If null, then delete the node, otherwise replace.
        let newNode = update(node);
        if (newNode == null) deleteNode(node);
        else addNode(newNode);
         // Walk up the tree and update each parent to refer to the new chilren.
        while(node.parentKey){
            let nextParent = map.get(node.parentKey);
            let copy = {
                key: nextParent.key,
                parentKey: nextParent.parentKey,
                value: nextParent.value,
                children: null
            };
            let children = nextParent.children;
            if (newNode == null) children = children.filter((c)=>c !== node
            );
            copy.children = children.map((child)=>{
                if (child === node) return newNode;
                return child;
            });
            map.set(copy.key, copy);
            newNode = copy;
            node = nextParent;
        }
        if (newNode == null) items1 = items1.filter((c)=>c !== node
        );
        return items1.map((item)=>{
            if (item === node) return newNode;
            return item;
        });
    }
    function addNode(node) {
        map.set(node.key, node);
        for (let child of node.children)addNode(child);
    }
    function deleteNode(node) {
        map.delete(node.key);
        for (let child of node.children)deleteNode(child);
    }
    return {
        items,
        selectedKeys,
        setSelectedKeys,
        getItem (key) {
            return map.get(key);
        },
        insert (parentKey, index) {
            for(var _len = arguments.length, values = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++)values[_key - 2] = arguments[_key];
            setItems((items1)=>{
                let nodes = buildTree(values, parentKey); // If parentKey is null, insert into the root.
                if (parentKey == null) return [
                    ...items1.slice(0, index),
                    ...nodes,
                    ...items1.slice(index)
                ];
                 // Otherwise, update the parent node and its ancestors.
                return updateTree(items1, parentKey, (parentNode)=>({
                        key: parentNode.key,
                        parentKey: parentNode.parentKey,
                        value: parentNode.value,
                        children: [
                            ...parentNode.children.slice(0, index),
                            ...nodes,
                            ...parentNode.children.slice(index)
                        ]
                    })
                );
            });
        },
        insertBefore (key) {
            let node = map.get(key);
            if (!node) return;
            let parentNode = map.get(node.parentKey);
            let nodes = parentNode ? parentNode.children : items;
            let index = nodes.indexOf(node);
            for(var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)values[_key2 - 1] = arguments[_key2];
            this.insert(parentNode == null ? void 0 : parentNode.key, index, ...values);
        },
        insertAfter (key) {
            let node = map.get(key);
            if (!node) return;
            let parentNode = map.get(node.parentKey);
            let nodes = parentNode ? parentNode.children : items;
            let index = nodes.indexOf(node);
            for(var _len3 = arguments.length, values = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++)values[_key3 - 1] = arguments[_key3];
            this.insert(parentNode == null ? void 0 : parentNode.key, index + 1, ...values);
        },
        prepend (parentKey) {
            for(var _len4 = arguments.length, values = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++)values[_key4 - 1] = arguments[_key4];
            this.insert(parentKey, 0, ...values);
        },
        append (parentKey) {
            for(var _len5 = arguments.length, values = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++)values[_key5 - 1] = arguments[_key5];
            if (parentKey == null) this.insert(null, items.length, ...values);
            else {
                let parentNode = map.get(parentKey);
                if (!parentNode) return;
                this.insert(parentKey, parentNode.children.length, ...values);
            }
        },
        remove () {
            let newItems = items;
            for(var _len6 = arguments.length, keys = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++)keys[_key6] = arguments[_key6];
            for (let key of keys)newItems = updateTree(newItems, key, ()=>null
            );
            setItems(newItems);
            let selection = new Set(selectedKeys);
            for (let key1 of selectedKeys)if (!map.has(key1)) selection.delete(key1);
            setSelectedKeys(selection);
        },
        removeSelectedItems () {
            this.remove(...selectedKeys);
        },
        move (key, toParentKey, index) {
            setItems((items1)=>{
                let node = map.get(key);
                if (!node) return items1;
                items1 = updateTree(items1, key, ()=>null
                );
                return updateTree(items1, toParentKey, (parentNode)=>({
                        key: parentNode.key,
                        parentKey: parentNode.parentKey,
                        value: parentNode.value,
                        children: [
                            ...parentNode.children.slice(0, index),
                            node,
                            ...parentNode.children.slice(index)
                        ]
                    })
                );
            });
        },
        update (oldKey, newValue) {
            setItems((items1)=>updateTree(items1, oldKey, (oldNode)=>{
                    let node = {
                        key: oldNode.key,
                        parentKey: oldNode.parentKey,
                        value: newValue,
                        children: null
                    };
                    node.children = buildTree(getChildren(newValue), node.key);
                    return node;
                })
            );
        }
    };
}
exports.useTreeData = useTreeData;
