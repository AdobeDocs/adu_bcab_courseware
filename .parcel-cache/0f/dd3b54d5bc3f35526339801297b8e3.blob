var { useFocusable  } = require("@react-aria/focus");
var { useEffect , useRef  } = require("react");
var _babelRuntimeHelpersExtends = $parcel$interopDefault(require("@babel/runtime/helpers/extends"));
var { useHover , getInteractionModality , isFocusVisible , usePress  } = require("@react-aria/interactions");
var { filterDOMProps , mergeProps , useId  } = require("@react-aria/utils");
function $parcel$interopDefault(a) {
    return a && a.__esModule ? a.default : a;
}
/**
 * Provides the accessibility implementation for a Tooltip component.
 */ function useTooltip(props, state) {
    let domProps = filterDOMProps(props, {
        labelable: true
    });
    let { hoverProps  } = useHover({
        onHoverStart: ()=>state == null ? void 0 : state.open(true)
        ,
        onHoverEnd: ()=>state == null ? void 0 : state.close()
    });
    return {
        tooltipProps: mergeProps(domProps, hoverProps, {
            role: 'tooltip'
        })
    };
}
exports.useTooltip = useTooltip;
/**
 * Provides the behavior and accessibility implementation for a tooltip trigger, e.g. a button
 * that shows a description when focused or hovered.
 */ function useTooltipTrigger(props, state, ref) {
    let { isDisabled , trigger  } = props;
    let tooltipId = useId();
    let isHovered = useRef(false);
    let isFocused = useRef(false);
    let handleShow = ()=>{
        if (isHovered.current || isFocused.current) state.open(isFocused.current);
    };
    let handleHide = (immediate)=>{
        if (!isHovered.current && !isFocused.current) state.close(immediate);
    };
    useEffect(()=>{
        let onKeyDown = (e)=>{
            if (ref && ref.current) // Escape after clicking something can give it keyboard focus
            // dismiss tooltip on esc key press
            {
                if (e.key === 'Escape') state.close(true);
            }
        };
        if (state.isOpen) {
            document.addEventListener('keydown', onKeyDown, true);
            return ()=>{
                document.removeEventListener('keydown', onKeyDown, true);
            };
        }
    }, [
        ref,
        state
    ]);
    let onHoverStart = ()=>{
        if (trigger === 'focus') return;
         // In chrome, if you hover a trigger, then another element obscures it, due to keyboard
        // interactions for example, hover will end. When hover is restored after that element disappears,
        // focus moves on for example, then the tooltip will reopen. We check the modality to know if the hover
        // is the result of moving the mouse.
        if (getInteractionModality() === 'pointer') isHovered.current = true;
        else isHovered.current = false;
        handleShow();
    };
    let onHoverEnd = ()=>{
        if (trigger === 'focus') return;
         // no matter how the trigger is left, we should close the tooltip
        isFocused.current = false;
        isHovered.current = false;
        handleHide();
    };
    let onPressStart = ()=>{
        // no matter how the trigger is pressed, we should close the tooltip
        isFocused.current = false;
        isHovered.current = false;
        handleHide(true);
    };
    let onFocus = ()=>{
        let isVisible = isFocusVisible();
        if (isVisible) {
            isFocused.current = true;
            handleShow();
        }
    };
    let onBlur = ()=>{
        isFocused.current = false;
        isHovered.current = false;
        handleHide(true);
    };
    let { hoverProps  } = useHover({
        isDisabled,
        onHoverStart,
        onHoverEnd
    });
    let { pressProps  } = usePress({
        onPressStart
    });
    let { focusableProps  } = useFocusable({
        isDisabled,
        onFocus,
        onBlur
    }, ref);
    return {
        triggerProps: _babelRuntimeHelpersExtends({
            'aria-describedby': state.isOpen ? tooltipId : undefined
        }, mergeProps(focusableProps, hoverProps, pressProps)),
        tooltipProps: {
            id: tooltipId
        }
    };
}
exports.useTooltipTrigger = useTooltipTrigger;
