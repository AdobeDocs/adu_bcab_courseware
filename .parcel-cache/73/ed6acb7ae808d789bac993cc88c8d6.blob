var { mergeProps , useLayoutEffect , useResizeObserver  } = require("@react-aria/utils");
exports.useResizeObserver = useResizeObserver;
var { useLocale  } = require("@react-aria/i18n");
var _babelRuntimeHelpersObjectWithoutPropertiesLoose = $parcel$interopDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));
var _babelRuntimeHelpersExtends = $parcel$interopDefault(require("@babel/runtime/helpers/extends"));
var { useIsSSR  } = require("@react-aria/ssr");
var _react2 = require("react");
var _react = $parcel$interopDefault(_react2);
var { useEffect , useState , useImperativeHandle , useMemo , useRef , useContext , useCallback  } = _react2;
var _clsx = $parcel$interopDefault(require("clsx"));
function $parcel$interopDefault(a) {
    return a && a.__esModule ? a.default : a;
}
let shouldKeepSpectrumClassNames = false;
exports.shouldKeepSpectrumClassNames = shouldKeepSpectrumClassNames;
function keepSpectrumClassNames() {
    shouldKeepSpectrumClassNames = true;
    exports.shouldKeepSpectrumClassNames = shouldKeepSpectrumClassNames;
    console.warn("Legacy spectrum-prefixed class names enabled for backward compatibility. We recommend replacing instances of CSS overrides targeting spectrum selectors in your app with custom class names of your own, and disabling this flag.");
}
exports.keepSpectrumClassNames = keepSpectrumClassNames;
function classNames(cssModule) {
    let classes = [];
    for(var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)values[_key - 1] = arguments[_key];
    for (let value of values){
        if (typeof value === 'object' && value) {
            let mapped = {
            };
            for(let key in value){
                if (cssModule[key]) mapped[cssModule[key]] = value[key];
                if (shouldKeepSpectrumClassNames || !cssModule[key]) mapped[key] = value[key];
            }
            classes.push(mapped);
        } else if (typeof value === 'string') {
            if (cssModule[value]) classes.push(cssModule[value]);
            if (shouldKeepSpectrumClassNames || !cssModule[value]) classes.push(value);
        } else classes.push(value);
    }
    return _clsx(...classes);
}
exports.classNames = classNames;
function getWrappedElement(children) {
    let element;
    if (typeof children === 'string') element = /*#__PURE__*/ _react.createElement("span", null, children);
    else element = _react.Children.only(children);
    return element;
}
exports.getWrappedElement = getWrappedElement;
function useMediaQuery(query) {
    let supportsMatchMedia = typeof window !== 'undefined' && typeof window.matchMedia === 'function';
    let [matches, setMatches] = useState(()=>supportsMatchMedia ? window.matchMedia(query).matches : false
    );
    useEffect(()=>{
        if (!supportsMatchMedia) return;
        let mq = window.matchMedia(query);
        let onChange = (evt)=>{
            setMatches(evt.matches);
        };
        mq.addListener(onChange);
        return ()=>{
            mq.removeListener(onChange);
        };
    }, [
        supportsMatchMedia,
        query
    ]); // If in SSR, the media query should never match. Once the page hydrates,
    // this will update and the real value will be returned.
    let isSSR = useIsSSR();
    return isSSR ? false : matches;
}
exports.useMediaQuery = useMediaQuery;
function createDOMRef(ref) {
    return {
        UNSAFE_getDOMNode () {
            return ref.current;
        }
    };
}
exports.createDOMRef = createDOMRef;
function createFocusableRef(domRef, focusableRef) {
    if (focusableRef === void 0) focusableRef = domRef;
    return _babelRuntimeHelpersExtends({
    }, createDOMRef(domRef), {
        focus () {
            if (focusableRef.current) focusableRef.current.focus();
        }
    });
}
exports.createFocusableRef = createFocusableRef;
function useDOMRef(ref) {
    let domRef = useRef(null);
    useImperativeHandle(ref, ()=>createDOMRef(domRef)
    );
    return domRef;
}
exports.useDOMRef = useDOMRef;
function useFocusableRef(ref, focusableRef) {
    let domRef = useRef(null);
    useImperativeHandle(ref, ()=>createFocusableRef(domRef, focusableRef)
    );
    return domRef;
}
exports.useFocusableRef = useFocusableRef;
function unwrapDOMRef(ref) {
    return {
        get current () {
            return ref.current && ref.current.UNSAFE_getDOMNode();
        }
    };
}
exports.unwrapDOMRef = unwrapDOMRef;
function useUnwrapDOMRef(ref) {
    return useMemo(()=>unwrapDOMRef(ref)
    , [
        ref
    ]);
}
exports.useUnwrapDOMRef = useUnwrapDOMRef;
const $a7996575bce26478d1cdac9b52b1cf84$var$Context = /*#__PURE__*/ _react.createContext(null);
$a7996575bce26478d1cdac9b52b1cf84$var$Context.displayName = 'BreakpointContext';
function BreakpointProvider(props) {
    let { children , matchedBreakpoints  } = props;
    return(/*#__PURE__*/ _react.createElement($a7996575bce26478d1cdac9b52b1cf84$var$Context.Provider, {
        value: {
            matchedBreakpoints
        }
    }, children));
}
exports.BreakpointProvider = BreakpointProvider;
function useMatchedBreakpoints(breakpoints) {
    let entries = Object.entries(breakpoints).sort((_ref, _ref2)=>{
        let [, valueA] = _ref;
        let [, valueB] = _ref2;
        return valueB - valueA;
    });
    let breakpointQueries = entries.map((_ref3)=>{
        let [, value] = _ref3;
        return "(min-width: " + value + "px)";
    });
    let supportsMatchMedia = typeof window !== 'undefined' && typeof window.matchMedia === 'function';
    let getBreakpointHandler = ()=>{
        let matched = [];
        for(let i in breakpointQueries){
            let query = breakpointQueries[i];
            if (window.matchMedia(query).matches) matched.push(entries[i][0]);
        }
        matched.push('base');
        return matched;
    };
    let [breakpoint, setBreakpoint] = useState(()=>supportsMatchMedia ? getBreakpointHandler() : [
            'base'
        ]
    );
    useEffect(()=>{
        if (!supportsMatchMedia) return;
        let onResize = ()=>{
            setBreakpoint(getBreakpointHandler());
        };
        window.addEventListener('resize', onResize);
        return ()=>{
            window.removeEventListener('resize', onResize);
        };
    }, [
        supportsMatchMedia
    ]); // If in SSR, the media query should never match. Once the page hydrates,
    // this will update and the real value will be returned.
    let isSSR = useIsSSR();
    return isSSR ? [
        'base'
    ] : breakpoint;
}
exports.useMatchedBreakpoints = useMatchedBreakpoints;
function useBreakpoint() {
    return useContext($a7996575bce26478d1cdac9b52b1cf84$var$Context);
}
exports.useBreakpoint = useBreakpoint;
const baseStyleProps = {
    margin: [
        'margin',
        dimensionValue
    ],
    marginStart: [
        $fde11e9d9d7d059795140092a2808e57$var$rtl('marginLeft', 'marginRight'),
        dimensionValue
    ],
    marginEnd: [
        $fde11e9d9d7d059795140092a2808e57$var$rtl('marginRight', 'marginLeft'),
        dimensionValue
    ],
    // marginLeft: ['marginLeft', dimensionValue],
    // marginRight: ['marginRight', dimensionValue],
    marginTop: [
        'marginTop',
        dimensionValue
    ],
    marginBottom: [
        'marginBottom',
        dimensionValue
    ],
    marginX: [
        [
            'marginLeft',
            'marginRight'
        ],
        dimensionValue
    ],
    marginY: [
        [
            'marginTop',
            'marginBottom'
        ],
        dimensionValue
    ],
    width: [
        'width',
        dimensionValue
    ],
    height: [
        'height',
        dimensionValue
    ],
    minWidth: [
        'minWidth',
        dimensionValue
    ],
    minHeight: [
        'minHeight',
        dimensionValue
    ],
    maxWidth: [
        'maxWidth',
        dimensionValue
    ],
    maxHeight: [
        'maxHeight',
        dimensionValue
    ],
    isHidden: [
        'display',
        $fde11e9d9d7d059795140092a2808e57$var$hiddenValue
    ],
    alignSelf: [
        'alignSelf',
        passthroughStyle
    ],
    justifySelf: [
        'justifySelf',
        passthroughStyle
    ],
    position: [
        'position',
        $fde11e9d9d7d059795140092a2808e57$var$anyValue
    ],
    zIndex: [
        'zIndex',
        $fde11e9d9d7d059795140092a2808e57$var$anyValue
    ],
    top: [
        'top',
        dimensionValue
    ],
    bottom: [
        'bottom',
        dimensionValue
    ],
    start: [
        $fde11e9d9d7d059795140092a2808e57$var$rtl('left', 'right'),
        dimensionValue
    ],
    end: [
        $fde11e9d9d7d059795140092a2808e57$var$rtl('right', 'left'),
        dimensionValue
    ],
    left: [
        'left',
        dimensionValue
    ],
    right: [
        'right',
        dimensionValue
    ],
    order: [
        'order',
        $fde11e9d9d7d059795140092a2808e57$var$anyValue
    ],
    flex: [
        'flex',
        $fde11e9d9d7d059795140092a2808e57$var$flexValue
    ],
    flexGrow: [
        'flexGrow',
        passthroughStyle
    ],
    flexShrink: [
        'flexShrink',
        passthroughStyle
    ],
    flexBasis: [
        'flexBasis',
        passthroughStyle
    ],
    gridArea: [
        'gridArea',
        passthroughStyle
    ],
    gridColumn: [
        'gridColumn',
        passthroughStyle
    ],
    gridColumnEnd: [
        'gridColumnEnd',
        passthroughStyle
    ],
    gridColumnStart: [
        'gridColumnStart',
        passthroughStyle
    ],
    gridRow: [
        'gridRow',
        passthroughStyle
    ],
    gridRowEnd: [
        'gridRowEnd',
        passthroughStyle
    ],
    gridRowStart: [
        'gridRowStart',
        passthroughStyle
    ]
};
exports.baseStyleProps = baseStyleProps;
const viewStyleProps = _babelRuntimeHelpersExtends({
}, baseStyleProps, {
    backgroundColor: [
        'backgroundColor',
        $fde11e9d9d7d059795140092a2808e57$var$backgroundColorValue
    ],
    borderWidth: [
        'borderWidth',
        $fde11e9d9d7d059795140092a2808e57$var$borderSizeValue
    ],
    borderStartWidth: [
        $fde11e9d9d7d059795140092a2808e57$var$rtl('borderLeftWidth', 'borderRightWidth'),
        $fde11e9d9d7d059795140092a2808e57$var$borderSizeValue
    ],
    borderEndWidth: [
        $fde11e9d9d7d059795140092a2808e57$var$rtl('borderRightWidth', 'borderLeftWidth'),
        $fde11e9d9d7d059795140092a2808e57$var$borderSizeValue
    ],
    borderLeftWidth: [
        'borderLeftWidth',
        $fde11e9d9d7d059795140092a2808e57$var$borderSizeValue
    ],
    borderRightWidth: [
        'borderRightWidth',
        $fde11e9d9d7d059795140092a2808e57$var$borderSizeValue
    ],
    borderTopWidth: [
        'borderTopWidth',
        $fde11e9d9d7d059795140092a2808e57$var$borderSizeValue
    ],
    borderBottomWidth: [
        'borderBottomWidth',
        $fde11e9d9d7d059795140092a2808e57$var$borderSizeValue
    ],
    borderXWidth: [
        [
            'borderLeftWidth',
            'borderRightWidth'
        ],
        $fde11e9d9d7d059795140092a2808e57$var$borderSizeValue
    ],
    borderYWidth: [
        [
            'borderTopWidth',
            'borderBottomWidth'
        ],
        $fde11e9d9d7d059795140092a2808e57$var$borderSizeValue
    ],
    borderColor: [
        'borderColor',
        $fde11e9d9d7d059795140092a2808e57$var$borderColorValue
    ],
    borderStartColor: [
        $fde11e9d9d7d059795140092a2808e57$var$rtl('borderLeftColor', 'borderRightColor'),
        $fde11e9d9d7d059795140092a2808e57$var$borderColorValue
    ],
    borderEndColor: [
        $fde11e9d9d7d059795140092a2808e57$var$rtl('borderRightColor', 'borderLeftColor'),
        $fde11e9d9d7d059795140092a2808e57$var$borderColorValue
    ],
    borderLeftColor: [
        'borderLeftColor',
        $fde11e9d9d7d059795140092a2808e57$var$borderColorValue
    ],
    borderRightColor: [
        'borderRightColor',
        $fde11e9d9d7d059795140092a2808e57$var$borderColorValue
    ],
    borderTopColor: [
        'borderTopColor',
        $fde11e9d9d7d059795140092a2808e57$var$borderColorValue
    ],
    borderBottomColor: [
        'borderBottomColor',
        $fde11e9d9d7d059795140092a2808e57$var$borderColorValue
    ],
    borderXColor: [
        [
            'borderLeftColor',
            'borderRightColor'
        ],
        $fde11e9d9d7d059795140092a2808e57$var$borderColorValue
    ],
    borderYColor: [
        [
            'borderTopColor',
            'borderBottomColor'
        ],
        $fde11e9d9d7d059795140092a2808e57$var$borderColorValue
    ],
    borderRadius: [
        'borderRadius',
        $fde11e9d9d7d059795140092a2808e57$var$borderRadiusValue
    ],
    borderTopStartRadius: [
        $fde11e9d9d7d059795140092a2808e57$var$rtl('borderTopLeftRadius', 'borderTopRightRadius'),
        $fde11e9d9d7d059795140092a2808e57$var$borderRadiusValue
    ],
    borderTopEndRadius: [
        $fde11e9d9d7d059795140092a2808e57$var$rtl('borderTopRightRadius', 'borderTopLeftRadius'),
        $fde11e9d9d7d059795140092a2808e57$var$borderRadiusValue
    ],
    borderBottomStartRadius: [
        $fde11e9d9d7d059795140092a2808e57$var$rtl('borderBottomLeftRadius', 'borderBottomRightRadius'),
        $fde11e9d9d7d059795140092a2808e57$var$borderRadiusValue
    ],
    borderBottomEndRadius: [
        $fde11e9d9d7d059795140092a2808e57$var$rtl('borderBottomRightRadius', 'borderBottomLeftRadius'),
        $fde11e9d9d7d059795140092a2808e57$var$borderRadiusValue
    ],
    borderTopLeftRadius: [
        'borderTopLeftRadius',
        $fde11e9d9d7d059795140092a2808e57$var$borderRadiusValue
    ],
    borderTopRightRadius: [
        'borderTopRightRadius',
        $fde11e9d9d7d059795140092a2808e57$var$borderRadiusValue
    ],
    borderBottomLeftRadius: [
        'borderBottomLeftRadius',
        $fde11e9d9d7d059795140092a2808e57$var$borderRadiusValue
    ],
    borderBottomRightRadius: [
        'borderBottomRightRadius',
        $fde11e9d9d7d059795140092a2808e57$var$borderRadiusValue
    ],
    padding: [
        'padding',
        dimensionValue
    ],
    paddingStart: [
        $fde11e9d9d7d059795140092a2808e57$var$rtl('paddingLeft', 'paddingRight'),
        dimensionValue
    ],
    paddingEnd: [
        $fde11e9d9d7d059795140092a2808e57$var$rtl('paddingRight', 'paddingLeft'),
        dimensionValue
    ],
    paddingLeft: [
        'paddingLeft',
        dimensionValue
    ],
    paddingRight: [
        'paddingRight',
        dimensionValue
    ],
    paddingTop: [
        'paddingTop',
        dimensionValue
    ],
    paddingBottom: [
        'paddingBottom',
        dimensionValue
    ],
    paddingX: [
        [
            'paddingLeft',
            'paddingRight'
        ],
        dimensionValue
    ],
    paddingY: [
        [
            'paddingTop',
            'paddingBottom'
        ],
        dimensionValue
    ],
    overflow: [
        'overflow',
        passthroughStyle
    ]
});
exports.viewStyleProps = viewStyleProps;
const $fde11e9d9d7d059795140092a2808e57$var$borderStyleProps = {
    borderWidth: 'borderStyle',
    borderLeftWidth: 'borderLeftStyle',
    borderRightWidth: 'borderRightStyle',
    borderTopWidth: 'borderTopStyle',
    borderBottomWidth: 'borderBottomStyle'
};
function $fde11e9d9d7d059795140092a2808e57$var$rtl(ltr, rtl) {
    return (direction)=>direction === 'rtl' ? rtl : ltr
    ;
}
const $fde11e9d9d7d059795140092a2808e57$var$UNIT_RE = /(%|px|em|rem|vw|vh|auto|cm|mm|in|pt|pc|ex|ch|rem|vmin|vmax|fr)$/;
const $fde11e9d9d7d059795140092a2808e57$var$FUNC_RE = /^\s*\w+\(/;
const $fde11e9d9d7d059795140092a2808e57$var$SPECTRUM_VARIABLE_RE = /(static-)?size-\d+|single-line-(height|width)/g;
function dimensionValue(value) {
    if (typeof value === 'number') return value + 'px';
    if ($fde11e9d9d7d059795140092a2808e57$var$UNIT_RE.test(value)) return value;
    if ($fde11e9d9d7d059795140092a2808e57$var$FUNC_RE.test(value)) return value.replace($fde11e9d9d7d059795140092a2808e57$var$SPECTRUM_VARIABLE_RE, 'var(--spectrum-global-dimension-$&, var(--spectrum-alias-$&))');
    return "var(--spectrum-global-dimension-" + value + ", var(--spectrum-alias-" + value + "))";
}
exports.dimensionValue = dimensionValue;
function responsiveDimensionValue(value, matchedBreakpoints) {
    value = getResponsiveProp(value, matchedBreakpoints);
    return dimensionValue(value);
}
exports.responsiveDimensionValue = responsiveDimensionValue;
function $fde11e9d9d7d059795140092a2808e57$var$colorValue(value, type) {
    if (type === void 0) type = 'default';
    return "var(--spectrum-global-color-" + value + ", var(--spectrum-semantic-" + value + "-color-" + type + "))";
}
function $fde11e9d9d7d059795140092a2808e57$var$backgroundColorValue(value) {
    return "var(--spectrum-alias-background-color-" + value + ", " + $fde11e9d9d7d059795140092a2808e57$var$colorValue(value, 'background') + ")";
}
function $fde11e9d9d7d059795140092a2808e57$var$borderColorValue(value) {
    if (value === 'default') return 'var(--spectrum-alias-border-color)';
    return "var(--spectrum-alias-border-color-" + value + ", " + $fde11e9d9d7d059795140092a2808e57$var$colorValue(value, 'border') + ")";
}
function $fde11e9d9d7d059795140092a2808e57$var$borderSizeValue(value) {
    return "var(--spectrum-alias-border-size-" + value + ")";
}
function $fde11e9d9d7d059795140092a2808e57$var$borderRadiusValue(value) {
    return "var(--spectrum-alias-border-radius-" + value + ")";
}
function $fde11e9d9d7d059795140092a2808e57$var$hiddenValue(value) {
    return value ? 'none' : undefined;
}
function $fde11e9d9d7d059795140092a2808e57$var$anyValue(value) {
    return value;
}
function $fde11e9d9d7d059795140092a2808e57$var$flexValue(value) {
    if (typeof value === 'boolean') return value ? '1' : undefined;
    return '' + value;
}
function convertStyleProps(props, handlers, direction, matchedBreakpoints) {
    let style = {
    };
    for(let key in props){
        let styleProp = handlers[key];
        if (!styleProp || props[key] == null) continue;
        let [name, convert] = styleProp;
        if (typeof name === 'function') name = name(direction);
        let prop = getResponsiveProp(props[key], matchedBreakpoints);
        let value = convert(prop);
        if (Array.isArray(name)) for (let k of name)style[k] = value;
        else style[name] = value;
    }
    for(let prop in $fde11e9d9d7d059795140092a2808e57$var$borderStyleProps)if (style[prop]) {
        style[$fde11e9d9d7d059795140092a2808e57$var$borderStyleProps[prop]] = 'solid';
        style.boxSizing = 'border-box';
    }
    return style;
}
exports.convertStyleProps = convertStyleProps;
function useStyleProps(props, handlers, options) {
    if (handlers === void 0) handlers = baseStyleProps;
    if (options === void 0) options = {
    };
    let { UNSAFE_className , UNSAFE_style  } = props, otherProps = _babelRuntimeHelpersObjectWithoutPropertiesLoose(props, [
        "UNSAFE_className",
        "UNSAFE_style"
    ]);
    let breakpointProvider = useBreakpoint();
    let { direction  } = useLocale();
    let { matchedBreakpoints =(breakpointProvider == null ? void 0 : breakpointProvider.matchedBreakpoints) || [
        'base'
    ]  } = options;
    let styles = convertStyleProps(props, handlers, direction, matchedBreakpoints);
    let style = _babelRuntimeHelpersExtends({
    }, UNSAFE_style, styles); // @ts-ignore
    if (otherProps.className) console.warn("The className prop is unsafe and is unsupported in React Spectrum v3. Please use style props with Spectrum variables, or UNSAFE_className if you absolutely must do something custom. Note that this may break in future versions due to DOM structure changes.");
     // @ts-ignore
    if (otherProps.style) console.warn("The style prop is unsafe and is unsupported in React Spectrum v3. Please use style props with Spectrum variables, or UNSAFE_style if you absolutely must do something custom. Note that this may break in future versions due to DOM structure changes.");
    let styleProps = {
        style,
        className: UNSAFE_className
    };
    if (getResponsiveProp(props.isHidden, matchedBreakpoints)) styleProps.hidden = true;
    return {
        styleProps
    };
}
exports.useStyleProps = useStyleProps;
function passthroughStyle(value) {
    return value;
}
exports.passthroughStyle = passthroughStyle;
function getResponsiveProp(prop, matchedBreakpoints) {
    if (prop && typeof prop === 'object' && !Array.isArray(prop)) {
        for(let i = 0; i < matchedBreakpoints.length; i++){
            let breakpoint = matchedBreakpoints[i];
            if (prop[breakpoint] != null) return prop[breakpoint];
        }
        return prop.base;
    }
    return prop;
}
exports.getResponsiveProp = getResponsiveProp;
let $fda26b2aacd0a7728829de04d10c975$var$SlotContext = /*#__PURE__*/ _react.createContext(null);
function useSlotProps(props, defaultSlot) {
    let slot = props.slot || defaultSlot;
    let { [slot]: slotProps = {
    }  } = useContext($fda26b2aacd0a7728829de04d10c975$var$SlotContext) || {
    };
    return mergeProps(slotProps, props);
}
exports.useSlotProps = useSlotProps;
function cssModuleToSlots(cssModule) {
    return Object.keys(cssModule).reduce((acc, slot)=>{
        acc[slot] = {
            UNSAFE_className: cssModule[slot]
        };
        return acc;
    }, {
    });
}
exports.cssModuleToSlots = cssModuleToSlots;
function SlotProvider(props) {
    let parentSlots = useContext($fda26b2aacd0a7728829de04d10c975$var$SlotContext) || {
    };
    let { slots ={
    } , children  } = props; // Merge props for each slot from parent context and props
    let value = useMemo(()=>Object.keys(parentSlots).concat(Object.keys(slots)).reduce((o, p)=>_babelRuntimeHelpersExtends({
            }, o, {
                [p]: mergeProps(parentSlots[p] || {
                }, slots[p] || {
                })
            })
        , {
        })
    , [
        parentSlots,
        slots
    ]);
    return(/*#__PURE__*/ _react.createElement($fda26b2aacd0a7728829de04d10c975$var$SlotContext.Provider, {
        value: value
    }, children));
}
exports.SlotProvider = SlotProvider;
function ClearSlots(props) {
    let { children  } = props, otherProps = _babelRuntimeHelpersObjectWithoutPropertiesLoose(props, [
        "children"
    ]);
    let content = children;
    if (_react.Children.toArray(children).length <= 1) {
        if (typeof children === 'function') // need to know if the node is a string or something else that react can render that doesn't get props
        content = /*#__PURE__*/ _react.cloneElement(_react.Children.only(children), otherProps);
    }
    return(/*#__PURE__*/ _react.createElement($fda26b2aacd0a7728829de04d10c975$var$SlotContext.Provider, {
        value: {
        }
    }, content));
}
exports.ClearSlots = ClearSlots;
function useHasChild(query, ref) {
    let [hasChild, setHasChild] = useState(true);
    useLayoutEffect(()=>{
        setHasChild(!!(ref.current && ref.current.querySelector(query)));
    }, [
        setHasChild,
        query,
        ref
    ]);
    return hasChild;
}
exports.useHasChild = useHasChild;
const $dfba26b46b2b2f027a9d4ad19567e6fd$var$MOBILE_SCREEN_WIDTH = 700;
function useIsMobileDevice() {
    let isSSR = useIsSSR();
    if (isSSR || typeof window === 'undefined') return false;
    return window.screen.width <= $dfba26b46b2b2f027a9d4ad19567e6fd$var$MOBILE_SCREEN_WIDTH;
}
exports.useIsMobileDevice = useIsMobileDevice;
// This hook works like `useState`, but when setting the value, you pass a generator function
// that can yield multiple values. Each yielded value updates the state and waits for the next
// layout effect, then continues the generator. This allows sequential updates to state to be
// written linearly.
function useValueEffect(defaultValue) {
    let [value, setValue] = useState(defaultValue);
    let effect = useRef(null); // Store the function in a ref so we can always access the current version
    // which has the proper `value` in scope.
    let nextRef = useRef(null);
    nextRef.current = ()=>{
        // Run the generator to the next yield.
        let newValue = effect.current.next(); // If the generator is done, reset the effect.
        if (newValue.done) {
            effect.current = null;
            return;
        } // If the value is the same as the current value,
        // then continue to the next yield. Otherwise,
        // set the value in state and wait for the next layout effect.
        if (value === newValue.value) nextRef.current();
        else setValue(newValue.value);
    };
    useLayoutEffect(()=>{
        // If there is an effect currently running, continue to the next yield.
        if (effect.current) nextRef.current();
    });
    let queue = useCallback((fn)=>{
        effect.current = fn();
        nextRef.current();
    }, [
        effect,
        nextRef
    ]);
    return [
        value,
        queue
    ];
}
exports.useValueEffect = useValueEffect;
