var { useControlledState  } = require("@react-stately/utils");
var _babelRuntimeHelpersExtends = $parcel$interopDefault(require("@babel/runtime/helpers/extends"));
var { useCollection  } = require("@react-stately/collections");
var { SelectionManager , useMultipleSelectionState  } = require("@react-stately/selection");
var { useEffect , useMemo  } = require("react");
function $parcel$interopDefault(a) {
    return a && a.__esModule ? a.default : a;
}
let $b42f1d5166481a4c34c86bbfb4215e1$var$_Symbol$iterator;
$b42f1d5166481a4c34c86bbfb4215e1$var$_Symbol$iterator = Symbol.iterator;
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ class ListCollection {
    constructor(nodes){
        var _last;
        this.keyMap = new Map();
        this.iterable = void 0;
        this.firstKey = void 0;
        this.lastKey = void 0;
        this.iterable = nodes;
        let visit = (node)=>{
            this.keyMap.set(node.key, node);
            if (node.childNodes && node.type === 'section') for (let child of node.childNodes)visit(child);
        };
        for (let node of nodes)visit(node);
        let last;
        let index = 0;
        for (let [key1, node1] of this.keyMap){
            if (last) {
                last.nextKey = key1;
                node1.prevKey = last.key;
            } else {
                this.firstKey = key1;
                node1.prevKey = undefined;
            }
            if (node1.type === 'item') node1.index = index++;
            last = node1; // Set nextKey as undefined since this might be the last node
            // If it isn't the last node, last.nextKey will properly set at start of new loop
            last.nextKey = undefined;
        }
        this.lastKey = (_last = last) == null ? void 0 : _last.key;
    }
    *[$b42f1d5166481a4c34c86bbfb4215e1$var$_Symbol$iterator]() {
        yield* this.iterable;
    }
    get size() {
        return this.keyMap.size;
    }
    getKeys() {
        return this.keyMap.keys();
    }
    getKeyBefore(key) {
        let node2 = this.keyMap.get(key);
        return node2 ? node2.prevKey : null;
    }
    getKeyAfter(key) {
        let node2 = this.keyMap.get(key);
        return node2 ? node2.nextKey : null;
    }
    getFirstKey() {
        return this.firstKey;
    }
    getLastKey() {
        return this.lastKey;
    }
    getItem(key) {
        return this.keyMap.get(key);
    }
}
exports.ListCollection = ListCollection;
/**
 * Provides state management for list-like components. Handles building a collection
 * of items from props, and manages multiple selection state.
 */ function useListState(props) {
    let { filter  } = props;
    let selectionState = useMultipleSelectionState(props);
    let disabledKeys = useMemo(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set()
    , [
        props.disabledKeys
    ]);
    let factory = (nodes1)=>filter ? new ListCollection(filter(nodes1)) : new ListCollection(nodes1)
    ;
    let context = useMemo(()=>({
            suppressTextValueWarning: props.suppressTextValueWarning
        })
    , [
        props.suppressTextValueWarning
    ]);
    let collection = useCollection(props, factory, context, [
        filter
    ]); // Reset focused key if that item is deleted from the collection.
    useEffect(()=>{
        if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) selectionState.setFocusedKey(null);
    }, [
        collection,
        selectionState.focusedKey
    ]);
    return {
        collection,
        disabledKeys,
        selectionManager: new SelectionManager(collection, selectionState)
    };
}
exports.useListState = useListState;
/**
 * Provides state management for list-like components with single selection.
 * Handles building a collection of items from props, and manages selection state.
 */ function useSingleSelectListState(props) {
    var _props$defaultSelecte;
    let [selectedKey, setSelectedKey] = useControlledState(props.selectedKey, (_props$defaultSelecte = props.defaultSelectedKey) != null ? _props$defaultSelecte : null, props.onSelectionChange);
    let selectedKeys = useMemo(()=>selectedKey != null ? [
            selectedKey
        ] : []
    , [
        selectedKey
    ]);
    let { collection , disabledKeys , selectionManager  } = useListState(_babelRuntimeHelpersExtends({
    }, props, {
        selectionMode: 'single',
        disallowEmptySelection: true,
        selectedKeys,
        onSelectionChange: (keys)=>{
            let key2 = keys.values().next().value; // Always fire onSelectionChange, even if the key is the same
            // as the current key (useControlledState does not).
            if (key2 === selectedKey && props.onSelectionChange) props.onSelectionChange(key2);
            setSelectedKey(key2);
        }
    }));
    let selectedItem = selectedKey != null ? collection.getItem(selectedKey) : null;
    return {
        collection,
        disabledKeys,
        selectionManager,
        selectedKey,
        setSelectedKey,
        selectedItem
    };
}
exports.useSingleSelectListState = useSingleSelectListState;
