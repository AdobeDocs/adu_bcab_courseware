var { useOverlayTriggerState  } = require("@react-stately/overlays");
var { useEffect , useMemo , useRef  } = require("react");
const $dbf206483fc3f3f5862f69116107e0c$var$TOOLTIP_DELAY = 1500; // this seems to be a 1.5 second delay, check with design
const $dbf206483fc3f3f5862f69116107e0c$var$TOOLTIP_COOLDOWN = 500;
let $dbf206483fc3f3f5862f69116107e0c$var$tooltips = {
};
let $dbf206483fc3f3f5862f69116107e0c$var$tooltipId = 0;
let $dbf206483fc3f3f5862f69116107e0c$var$globalWarmedUp = false;
let $dbf206483fc3f3f5862f69116107e0c$var$globalWarmUpTimeout = null;
let $dbf206483fc3f3f5862f69116107e0c$var$globalCooldownTimeout = null;
/**
 * Manages state for a tooltip trigger. Tracks whether the tooltip is open, and provides
 * methods to toggle this state. Ensures only one tooltip is open at a time and controls
 * the delay for showing a tooltip.
 */ function useTooltipTriggerState(props) {
    if (props === void 0) props = {
    };
    let { delay =$dbf206483fc3f3f5862f69116107e0c$var$TOOLTIP_DELAY  } = props;
    let { isOpen , open , close  } = useOverlayTriggerState(props);
    let id = useMemo(()=>"" + ++$dbf206483fc3f3f5862f69116107e0c$var$tooltipId
    , []);
    let closeTimeout = useRef();
    let ensureTooltipEntry = ()=>{
        $dbf206483fc3f3f5862f69116107e0c$var$tooltips[id] = hideTooltip;
    };
    let closeOpenTooltips = ()=>{
        for(let hideTooltipId in $dbf206483fc3f3f5862f69116107e0c$var$tooltips)if (hideTooltipId !== id) {
            $dbf206483fc3f3f5862f69116107e0c$var$tooltips[hideTooltipId](true);
            delete $dbf206483fc3f3f5862f69116107e0c$var$tooltips[hideTooltipId];
        }
    };
    let showTooltip = ()=>{
        clearTimeout(closeTimeout.current);
        closeTimeout.current = null;
        closeOpenTooltips();
        ensureTooltipEntry();
        $dbf206483fc3f3f5862f69116107e0c$var$globalWarmedUp = true;
        open();
        if ($dbf206483fc3f3f5862f69116107e0c$var$globalWarmUpTimeout) {
            clearTimeout($dbf206483fc3f3f5862f69116107e0c$var$globalWarmUpTimeout);
            $dbf206483fc3f3f5862f69116107e0c$var$globalWarmUpTimeout = null;
        }
        if ($dbf206483fc3f3f5862f69116107e0c$var$globalCooldownTimeout) {
            clearTimeout($dbf206483fc3f3f5862f69116107e0c$var$globalCooldownTimeout);
            $dbf206483fc3f3f5862f69116107e0c$var$globalCooldownTimeout = null;
        }
    };
    let hideTooltip = (immediate)=>{
        if (immediate) {
            clearTimeout(closeTimeout.current);
            closeTimeout.current = null;
            close();
        } else if (!closeTimeout.current) closeTimeout.current = setTimeout(()=>{
            closeTimeout.current = null;
            close();
        }, $dbf206483fc3f3f5862f69116107e0c$var$TOOLTIP_COOLDOWN);
        if ($dbf206483fc3f3f5862f69116107e0c$var$globalWarmUpTimeout) {
            clearTimeout($dbf206483fc3f3f5862f69116107e0c$var$globalWarmUpTimeout);
            $dbf206483fc3f3f5862f69116107e0c$var$globalWarmUpTimeout = null;
        }
        if ($dbf206483fc3f3f5862f69116107e0c$var$globalWarmedUp) {
            if ($dbf206483fc3f3f5862f69116107e0c$var$globalCooldownTimeout) clearTimeout($dbf206483fc3f3f5862f69116107e0c$var$globalCooldownTimeout);
            $dbf206483fc3f3f5862f69116107e0c$var$globalCooldownTimeout = setTimeout(()=>{
                delete $dbf206483fc3f3f5862f69116107e0c$var$tooltips[id];
                $dbf206483fc3f3f5862f69116107e0c$var$globalCooldownTimeout = null;
                $dbf206483fc3f3f5862f69116107e0c$var$globalWarmedUp = false;
            }, $dbf206483fc3f3f5862f69116107e0c$var$TOOLTIP_COOLDOWN);
        }
    };
    let warmupTooltip = ()=>{
        closeOpenTooltips();
        ensureTooltipEntry();
        if (!isOpen && !$dbf206483fc3f3f5862f69116107e0c$var$globalWarmUpTimeout && !$dbf206483fc3f3f5862f69116107e0c$var$globalWarmedUp) $dbf206483fc3f3f5862f69116107e0c$var$globalWarmUpTimeout = setTimeout(()=>{
            $dbf206483fc3f3f5862f69116107e0c$var$globalWarmUpTimeout = null;
            $dbf206483fc3f3f5862f69116107e0c$var$globalWarmedUp = true;
            showTooltip();
        }, delay);
        else if (!isOpen) showTooltip();
    }; // eslint-disable-next-line arrow-body-style
    useEffect(()=>{
        return ()=>{
            clearTimeout(closeTimeout.current);
            let tooltip = $dbf206483fc3f3f5862f69116107e0c$var$tooltips[id];
            if (tooltip) delete $dbf206483fc3f3f5862f69116107e0c$var$tooltips[id];
        };
    }, [
        id
    ]);
    return {
        isOpen,
        open: (immediate)=>{
            if (!immediate && delay > 0 && !closeTimeout.current) warmupTooltip();
            else showTooltip();
        },
        close: hideTooltip
    };
}
exports.useTooltipTriggerState = useTooltipTriggerState;
