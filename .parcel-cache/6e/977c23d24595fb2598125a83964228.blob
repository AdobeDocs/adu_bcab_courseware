var { useControlledState  } = require("@react-stately/utils");
var { useCollection  } = require("@react-stately/collections");
var { SelectionManager , useMultipleSelectionState  } = require("@react-stately/selection");
var { useEffect , useMemo  } = require("react");
let $f4c7caecb598119f63e2918a55ec91a9$var$_Symbol$iterator;
$f4c7caecb598119f63e2918a55ec91a9$var$_Symbol$iterator = Symbol.iterator;
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ class $f4c7caecb598119f63e2918a55ec91a9$export$TreeCollection {
    constructor(nodes, _temp){
        var _last;
        let { expandedKeys  } = _temp === void 0 ? {
        } : _temp;
        this.keyMap = new Map();
        this.iterable = void 0;
        this.firstKey = void 0;
        this.lastKey = void 0;
        this.iterable = nodes;
        expandedKeys = expandedKeys || new Set();
        let visit = (node)=>{
            this.keyMap.set(node.key, node);
            if (node.childNodes && (node.type === 'section' || expandedKeys.has(node.key))) for (let child of node.childNodes)visit(child);
        };
        for (let node of nodes)visit(node);
        let last;
        let index = 0;
        for (let [key1, node1] of this.keyMap){
            if (last) {
                last.nextKey = key1;
                node1.prevKey = last.key;
            } else {
                this.firstKey = key1;
                node1.prevKey = undefined;
            }
            if (node1.type === 'item') node1.index = index++;
            last = node1; // Set nextKey as undefined since this might be the last node
            // If it isn't the last node, last.nextKey will properly set at start of new loop
            last.nextKey = undefined;
        }
        this.lastKey = (_last = last) == null ? void 0 : _last.key;
    }
    *[$f4c7caecb598119f63e2918a55ec91a9$var$_Symbol$iterator]() {
        yield* this.iterable;
    }
    get size() {
        return this.keyMap.size;
    }
    getKeys() {
        return this.keyMap.keys();
    }
    getKeyBefore(key) {
        let node2 = this.keyMap.get(key);
        return node2 ? node2.prevKey : null;
    }
    getKeyAfter(key) {
        let node2 = this.keyMap.get(key);
        return node2 ? node2.nextKey : null;
    }
    getFirstKey() {
        return this.firstKey;
    }
    getLastKey() {
        return this.lastKey;
    }
    getItem(key) {
        return this.keyMap.get(key);
    }
}
/**
 * Provides state management for tree-like components. Handles building a collection
 * of items from props, item expanded state, and manages multiple selection state.
 */ function useTreeState(props) {
    let [expandedKeys1, setExpandedKeys] = useControlledState(props.expandedKeys ? new Set(props.expandedKeys) : undefined, props.defaultExpandedKeys ? new Set(props.defaultExpandedKeys) : new Set(), props.onExpandedChange);
    let selectionState = useMultipleSelectionState(props);
    let disabledKeys = useMemo(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set()
    , [
        props.disabledKeys
    ]);
    let tree = useCollection(props, (nodes1)=>new $f4c7caecb598119f63e2918a55ec91a9$export$TreeCollection(nodes1, {
            expandedKeys: expandedKeys1
        })
    , null, [
        expandedKeys1
    ]); // Reset focused key if that item is deleted from the collection.
    useEffect(()=>{
        if (selectionState.focusedKey != null && !tree.getItem(selectionState.focusedKey)) selectionState.setFocusedKey(null);
    }, [
        tree,
        selectionState.focusedKey
    ]);
    let onToggle = (key2)=>{
        setExpandedKeys((expandedKeys2)=>$f01b8043d944d5f04fffbeb1df9fd6cb$var$toggleKey(expandedKeys2, key2)
        );
    };
    return {
        collection: tree,
        expandedKeys: expandedKeys1,
        disabledKeys,
        toggleKey: onToggle,
        selectionManager: new SelectionManager(tree, selectionState)
    };
}
exports.useTreeState = useTreeState;
function $f01b8043d944d5f04fffbeb1df9fd6cb$var$toggleKey(set, key2) {
    let res = new Set(set);
    if (res.has(key2)) res.delete(key2);
    else res.add(key2);
    return res;
}
