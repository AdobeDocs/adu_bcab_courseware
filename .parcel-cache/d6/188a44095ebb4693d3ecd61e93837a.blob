var { useVisuallyHidden  } = require("@react-aria/visually-hidden");
var { useMenuTrigger  } = require("@react-aria/menu");
var { useLabel  } = require("@react-aria/label");
var { useCollator  } = require("@react-aria/i18n");
var { setInteractionModality , useInteractionModality  } = require("@react-aria/interactions");
var { ListKeyboardDelegate , useTypeSelect  } = require("@react-aria/selection");
var _react2 = require("react");
var _react = $parcel$interopDefault(_react2);
var { useMemo  } = _react2;
var { chain , filterDOMProps , mergeProps , useId  } = require("@react-aria/utils");
var _babelRuntimeHelpersExtends = $parcel$interopDefault(require("@babel/runtime/helpers/extends"));
function $parcel$interopDefault(a) {
    return a && a.__esModule ? a.default : a;
}
/**
 * Provides the behavior and accessibility implementation for a select component.
 * A select displays a collapsible list of options and allows a user to select one of them.
 * @param props - Props for the select.
 * @param state - State for the select, as returned by `useListState`.
 */ function useSelect(props, state, ref) {
    let { keyboardDelegate , isDisabled  } = props; // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).
    // When virtualized, the layout object will be passed in as a prop and override this.
    let collator = useCollator({
        usage: 'search',
        sensitivity: 'base'
    });
    let delegate = useMemo(()=>keyboardDelegate || new ListKeyboardDelegate(state.collection, state.disabledKeys, null, collator)
    , [
        keyboardDelegate,
        state.collection,
        state.disabledKeys,
        collator
    ]);
    let { menuTriggerProps , menuProps  } = useMenuTrigger({
        isDisabled,
        type: 'listbox'
    }, state, ref);
    let onKeyDown = (e)=>{
        switch(e.key){
            case 'ArrowLeft':
                {
                    // prevent scrolling containers
                    e.preventDefault();
                    let key = state.selectedKey != null ? delegate.getKeyAbove(state.selectedKey) : delegate.getFirstKey();
                    if (key) state.setSelectedKey(key);
                    break;
                }
            case 'ArrowRight':
                {
                    // prevent scrolling containers
                    e.preventDefault();
                    let key = state.selectedKey != null ? delegate.getKeyBelow(state.selectedKey) : delegate.getFirstKey();
                    if (key) state.setSelectedKey(key);
                    break;
                }
        }
    };
    let { typeSelectProps  } = useTypeSelect({
        keyboardDelegate: delegate,
        selectionManager: state.selectionManager,
        onTypeSelect (key) {
            state.setSelectedKey(key);
        }
    });
    let { labelProps , fieldProps  } = useLabel(_babelRuntimeHelpersExtends({
    }, props, {
        labelElementType: 'span'
    }));
    typeSelectProps.onKeyDown = typeSelectProps.onKeyDownCapture;
    delete typeSelectProps.onKeyDownCapture;
    let domProps = filterDOMProps(props, {
        labelable: true
    });
    let triggerProps = mergeProps(typeSelectProps, menuTriggerProps, fieldProps);
    let valueId = useId();
    return {
        labelProps: _babelRuntimeHelpersExtends({
        }, labelProps, {
            onClick: ()=>{
                if (!props.isDisabled) {
                    ref.current.focus(); // Show the focus ring so the user knows where focus went
                    setInteractionModality('keyboard');
                }
            }
        }),
        triggerProps: mergeProps(domProps, _babelRuntimeHelpersExtends({
        }, triggerProps, {
            onKeyDown: chain(triggerProps.onKeyDown, onKeyDown, props.onKeyDown),
            onKeyUp: props.onKeyUp,
            'aria-labelledby': [
                triggerProps['aria-labelledby'],
                triggerProps['aria-label'] && !triggerProps['aria-labelledby'] ? triggerProps.id : null,
                valueId
            ].filter(Boolean).join(' '),
            onFocus (e) {
                if (state.isFocused) return;
                if (props.onFocus) props.onFocus(e);
                state.setFocused(true);
            },
            onBlur (e) {
                if (state.isOpen) return;
                if (props.onBlur) props.onBlur(e);
                state.setFocused(false);
            }
        })),
        valueProps: {
            id: valueId
        },
        menuProps: _babelRuntimeHelpersExtends({
        }, menuProps, {
            onBlur: (e)=>{
                if (e.currentTarget.contains(e.relatedTarget)) return;
                if (props.onBlur) props.onBlur(e);
                state.setFocused(false);
            },
            'aria-labelledby': [
                fieldProps['aria-labelledby'],
                triggerProps['aria-label'] && !fieldProps['aria-labelledby'] ? triggerProps.id : null
            ].filter(Boolean).join(' ')
        })
    };
}
exports.useSelect = useSelect;
/**
 * Provides the behavior and accessibility implementation for a hidden `<select>` element, which
 * can be used in combination with `useSelect` to support browser form autofill, mobile form
 * navigation, and native HTML form submission.
 */ function useHiddenSelect(props, state, triggerRef) {
    var _state$selectedKey;
    let { name , isDisabled  } = props;
    let modality = useInteractionModality();
    let { visuallyHiddenProps  } = useVisuallyHidden(); // In Safari, the <select> cannot have `display: none` or `hidden` for autofill to work.
    // In Firefox, there must be a <label> to identify the <select> whereas other browsers
    // seem to identify it just by surrounding text.
    // The solution is to use <VisuallyHidden> to hide the elements, which clips the elements to a
    // 1px rectangle. In addition, we hide from screen readers with aria-hidden, and make the <select>
    // non tabbable with tabIndex={-1}.
    //
    // In mobile browsers, there are next/previous buttons above the software keyboard for navigating
    // between fields in a form. These only support native form inputs that are tabbable. In order to
    // support those, an additional hidden input is used to marshall focus to the button. It is tabbable
    // except when the button is focused, so that shift tab works properly to go to the actual previous
    // input in the form. Using the <select> for this also works, but Safari on iOS briefly flashes
    // the native menu on focus, so this isn't ideal. A font-size of 16px or greater is required to
    // prevent Safari from zooming in on the input when it is focused.
    //
    // If the current interaction modality is null, then the user hasn't interacted with the page yet.
    // In this case, we set the tabIndex to -1 on the input element so that automated accessibility
    // checkers don't throw false-positives about focusable elements inside an aria-hidden parent.
    return {
        containerProps: _babelRuntimeHelpersExtends({
        }, visuallyHiddenProps, {
            'aria-hidden': true
        }),
        inputProps: {
            type: 'text',
            tabIndex: modality == null || state.isFocused || state.isOpen ? -1 : 0,
            style: {
                fontSize: 16
            },
            onFocus: ()=>triggerRef.current.focus()
            ,
            disabled: isDisabled
        },
        selectProps: {
            tabIndex: -1,
            disabled: isDisabled,
            name,
            size: state.collection.size,
            value: (_state$selectedKey = state.selectedKey) != null ? _state$selectedKey : '',
            onChange: (e)=>state.setSelectedKey(e.target.value)
        }
    };
}
/**
 * Renders a hidden native `<select>` element, which can be used to support browser
 * form autofill, mobile form navigation, and native form submission.
 */ exports.useHiddenSelect = useHiddenSelect;
function HiddenSelect(props) {
    let { state , triggerRef , label , name , isDisabled  } = props;
    let { containerProps , inputProps , selectProps  } = useHiddenSelect(props, state, triggerRef); // If used in a <form>, use a hidden input so the value can be submitted to a server.
    // If the collection isn't too big, use a hidden <select> element for this so that browser
    // autofill will work. Otherwise, use an <input type="hidden">.
    if (state.collection.size <= 300) return(/*#__PURE__*/ _react.createElement("div", containerProps, /*#__PURE__*/ _react.createElement("input", inputProps), /*#__PURE__*/ _react.createElement("label", null, label, /*#__PURE__*/ _react.createElement("select", selectProps, /*#__PURE__*/ _react.createElement("option", null), [
        ...state.collection.getKeys()
    ].map((key)=>{
        let item = state.collection.getItem(key);
        if (item.type === 'item') return(/*#__PURE__*/ _react.createElement("option", {
            key: item.key,
            value: item.key
        }, item.textValue));
    })))));
    else if (name) return(/*#__PURE__*/ _react.createElement("input", {
        type: "hidden",
        name: name,
        disabled: isDisabled,
        value: state.selectedKey
    }));
    return null;
}
exports.HiddenSelect = HiddenSelect;
